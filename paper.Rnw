\documentclass[AMS,STIX2COL]{WileyNJD-v2}

% Packages
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{natbib}
\usepackage{xcolor}

% Commands
\definecolor{orange}{rgb}{0.94, 0.59, 0.19}
\definecolor{purple}{rgb}{0.5, 0.0, 0.5}
\definecolor{teal}{rgb}{0, 0.502, 0.502}
\newcommand{\hh}[1]{\textcolor{orange}{#1}}
\newcommand{\kgc}[1]{\textcolor{purple}{#1}}
\newcommand{\kge}[1]{\textcolor{teal}{#1}}
\newcommand{\data}{sine data}
\renewcommand{\sout}[1]{\unskip}

% Set up for ASA data science journal
\articletype{Research Article}
\received{XX XX XXXX}
\revised{XX XX XXXX}
\accepted{XX XX XXXX}
\raggedbottom

\begin{document}

% Paper header (title and authors)
\title{Visual Diagnostics of an Explainer Model -- Tools for the Assessment of LIME Explanations}
\author[1]{Katherine Goode*}
\author[1,2]{Heike Hofmann}
\authormark{Goode and Hofmann}
\address[1]{\orgdiv{Department of Statistics}, \orgname{Iowa State University}, \orgaddress{\state{Iowa}, \country{United States}}}
\address[2]{\orgdiv{Center for Statistics and Applications in Forensic Evidence (CSAFE)}, \orgname{Iowa State University}, \orgaddress{\state{Iowa}, \country{United States}}}
\corres{*Katherine Goode, Department of Statistics, Iowa State University, Ames, IA. \email{kgoode@iastate.edu}}

% Abstract and keywords
\abstract[Abstract]{The importance of providing explanations for predictions made by black-box models has led to the development of explainer model methods such as LIME (local interpretable model-agnostic explanations). LIME uses a surrogate model to explain the relationship between predictor variables and predictions from a black-box model in a local region around a prediction of interest. However, the quality of the resulting explanations relies on how well the explainer model captures the black-box model in a specified local region. Here we introduce three visual diagnostics to assess the quality of LIME explanations: (1) explanation scatterplots, (2) assessment metric plots, and (3) feature heatmaps. We apply the visual diagnostics to a forensics bullet matching dataset to show examples where LIME explanations depend on the tuning parameter values and the explainer model oversimplifies the black-box model. Our examples raise concerns about claims made of LIME that are similar to other criticisms in the literature.}
\keywords{explainable machine learning, black-box models, interpretability, statistical graphics, data science}

% Citation information
\jnlcitation{
\cname{\author{Goode K.}, \author{H. Hofmann}},
\cyear{2020},
\ctitle{Visual Diagnostics of an Explainer Model -- Tools for the Assessment of LIME Explanations},
\cjournal{Stat Anal Data Min: The ASA Data Sci Journal},
\cvol{volume, number and page}.}

\maketitle

<<setup, echo = FALSE, include = FALSE>>=
# Specify global options
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  fig.keep = 'high',
  fig.align = 'center',
  dev = c("cairo_pdf", "cairo_ps"),
  dev.args = list(fallback_resolution = 800),
  dpi = 1200
)

# Load packages
library(bulletxtrctr) #remotes::install_github("heike/bulletxtrctr")
library(Cairo)
library(caret)
library(cowplot)
library(dplyr)
library(forcats)
library(ggforce)
library(ggplot2)
library(ggpcp) #remotes::install_github("yaweige/ggpcp")
library(glmnet)
library(gower)
library(graphics)
library(gretchenalbrecht) #remotes::install_github("dicook/gretchenalbrecht")
library(latex2exp)
library(lime) #remotes::install_github("goodekat/lime")
library(limeaid) #remotes::install_github("goodekat/limeaid")
library(magick)
library(purrr)
library(randomForest)
library(stringr)
library(tidyr)

# Specify the (base) font size (fs) and font (ff) for all plots
fs = 7
ff = "Helvetica"
@

\section{Introduction}

<<concept-data-explainer>>=

# Specify the gower exponents
good_gower_power <- 0.00000000000000005
bad_gower_power <- 1

# Specify a prediction of interest
poi <-
  data.frame(
    poi = "Prediction \nof Interest",
    feature = 0.1,
    prediction = 0.05
  )

# Simulate example data
set.seed(20190624)
concept_data <-
  data.frame(poi = "Training Data", 
             feature = sort(c(runif(100, 0, 1), runif(250, 0, 7)))) %>%
  mutate(prediction = sin(feature) + rnorm(350, 0, 0.25)) %>%
  bind_rows(poi)

# Compute the good distances between the prediction of interest
# and all other observations
concept_data$weights_good <-
  1 - (gower_dist(
    x = poi %>% select(feature),
    y = concept_data %>% select(feature)
  )) ^ good_gower_power

# Compute the bad distances between the prediction of interest
# and all other observations
concept_data$weights_bad <-
  1 - (gower_dist(
    x = poi %>% select(feature),
    y = concept_data %>% select(feature)
  )) ^ bad_gower_power

# Fit the good and bad interpretable explainer models
explainer_good <-
  lm(prediction ~ feature, data = concept_data, weights = weights_good)
explainer_bad <-
  lm(prediction ~ feature, data = concept_data, weights = weights_bad)
  
# Create labels for the gower powers
good_power_label <-
  paste0("Faithful Local Explainer \n(exponent used to compute weights: ",
         good_gower_power,
         ")")
bad_power_label <-
  paste0("Unfaithful Local Explainer \n(exponent used to compute weights: ",
         bad_gower_power,
         ")")

# Join the coefficients from the explainer model into a dataframe
coefs_data <-
  data.frame(
    case = c(good_power_label, bad_power_label),
    b0 = c(coef(explainer_good)[1],
           coef(explainer_bad)[1]),
    b1 = c(coef(explainer_good)[2],
           coef(explainer_bad)[2]),
    feature = 6,
    prediction = 1.6
  ) %>%
  mutate(text = paste0("Slope: ", round(b1, 3)))

# Prepare data for plotting
concept_data_long <-
  concept_data %>%
  pivot_longer(names_to = "case",
               values_to = "weight",
               cols = weights_good:weights_bad) %>%
  mutate(case = ifelse(case == "weights_good", good_power_label, bad_power_label))
@

\begin{figure*}[!thp]
<<figure-01, out.width = '6.5in', fig.width = 7.95, fig.height = 2.75, warning = FALSE>>=

# Specify the figure size (for determining font size)
f1_ow = 6.5
f1_fw = 7.95
f1_fs = fs * (f1_fw / f1_ow)

# Plot of good explainer model
ggplot() +
  facet_grid(. ~ case) +
  geom_point(
    data = concept_data_long,
    mapping = aes(
      x = feature,
      y = prediction,
      fill = poi,
      color = poi,
      shape = poi,
      alpha = poi,
      size = weight
    )
  ) +
  geom_abline(
    data = coefs_data,
    mapping = aes(intercept = b0, slope = b1),
    size = 1
  ) +
  scale_fill_manual(values = c("#FAAA72", "grey30")) +
  scale_color_manual(values = c("grey30", "grey30")) +
  scale_alpha_manual(values = c(0.75, 0.6)) +
  scale_shape_manual(values = c(23, 21)) +
  geom_text(
    data = coefs_data,
    mapping = aes(x = feature,
                  y = prediction,
                  label = text),
    family = ff,
    size = f1_fs / 2.85
  ) +
  labs(x = "Black-Box Model Feature",
       y = "Black-Box Prediction",
       size = "Weight", 
       fill = "", 
       color = "",
       alpha = "",
       shape = "") +
  theme_linedraw(base_family = ff, base_size = f1_fs) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    strip.placement = "outside",
    strip.background = element_rect(color = "white", fill = "white"),
    strip.text.x = element_text(size = f1_fs, color = "black"),
    plot.title = element_text(size = f1_fs)
  ) +
  guides(
    fill = guide_legend(order = 1, override.aes = list(size = 5)),
    color = guide_legend(order = 1),
    shape = guide_legend(order = 1),
    alpha = guide_legend(order = 1),
    size = guide_legend(
      order = 2,
      override.aes = list(color = "grey30", alpha = 0.6)
    )
  )

@
\caption{Hypothetical scenarios depicting the effect of different weights on LIME. (Left) An example of an explainer model with appropriate weights to provide a faithful approximation of the complex model. (Right) An example of an explainer model for the same prediction but with different weights that results in an explanation unfaithful to the complex model.}
\label{fig:figure-01}
\end{figure*}

In the field of statistics, there are two main uses for models: inference and prediction. Machine learning models have proven to perform well in problems with the latter objective, but the accuracy of many machine learning models comes at the cost of interpretability due to their algorithmic complexity (hence the phrase "black-box models"). Model interpretability allows for the understanding and assessment of how a model produces predictions. The lack of the ability to understand and assess a model makes it difficult to trust the model, especially in areas with high stakes decisions such as the medical and forensics sciences. The increased use of machine learning models in applications and the introduction of the General Data Protection Regulation (GDPR) in 2018 \citep{goodman:2016} has resulted in a dramatic increase in explainable machine learning research, which focuses on developing ways to explain output from machine learning algorithms.

Throughout this paper, we distinguish between interpretability and explanability of models. We define {\it interpretability} as the ability to directly use model parameters to understand the relationships in the data captured by the model: e.g., a linear model coefficient associated with a predictor variable indicates the amount the response variable changes based on a change in the predictor\sout{ variable}. In contrast, we define {\it explanability} as the ability to use the model in an indirect manner to understand the relationships in the data captured by the model: e.g., partial dependence plots depict the marginal relationship between model predictions and predictor variables \citep{friedman:2001}.

Numerous methods have been proposed to provide explanations for black-box model predictions \citep{gilpin:2018, guidotti:2018, ming:2017, molnar:2019}. Some are specific to one type of model (e.g. \citep{simonyan:2013} and \citep{urbanek:2008}), and others are model-agnostic (e.g. \citep{fisher:2018} and \citep{strumbelj:2014}). In this paper, we focus on the  model-agnostic method of LIME \citep{ribeiro:2016}.

LIME (local interpretable model-agnostic explanations) uses a surrogate model to relate predictor variables to black-box model predictions  \citep{ribeiro:2016}. While some explainer models focus on understanding a model at the global level, LIME claims to provide explanations for individual predictions (local). Additionally, LIME is designed to work with any model (model-agnostic) and to produce easily understandable results (explanations) \citep{ribeiro:2016}. Conceptually, LIME fits a simple (interpretable) model, the explainer model, to approximate  the complex model in a local region around a prediction of interest. The simple model is interpreted to identify the variables that most influence the complex model prediction.

While the concept of LIME is relatively simple, a practical implementation of LIME is not straightforward, and research is being done to improve the procedure \citep{laugel:2018}. The current implementations of LIME \citep{pedersen:2020, ribeiro:2020} offer various tuning parameters (see Section \ref{background}) that affect the explainer model and ultimately, the explanation. Since the explainer model is an approximation of the complex model and not a direct interpretation, the explanations produced by an explainer model are subject to the quality of the approximation. In order to achieve reasonable explanations, the tuning parameter values selected should  be assessed.

To demonstrate the effect of a tuning parameter on LIME, we consider two different explainer models applied to the same prediction. \autoref{fig:figure-01} depicts two plots of the predictions from a hypothetical black-box model versus the feature used to train the model. The location of a prediction of interest is indicated by the diamond shaped points. Globally, there is a clear non-linear relationship between the predictions and the feature, but the relationship could be approximated by a linear model in a local region around the prediction of interest. In both scenarios, a linear regression weighted by the proximity from an observation to the prediction of interest is used as the explainer model, but the proximities are computed differently as depicted by the varying sizes of the observations in the two plots.

On the left, the distance between an observation and the prediction of interest is computed using the Gower distance metric \citep{gower:1971} and then raised to the power of \Sexpr{good_gower_power} to emphasize a very local region. The distances are subtracted from 1 to obtain a proximity. Here, the explainer model is faithful to the complex model since it captures the linear relationship between the black-box predictions in an immediate neighborhood of the prediction of interest. The slope explains that the black-box predictions increase as the feature increases in the local region around the prediction of interest.

For the scenario on the right, the computation of the proximities is the same except the distances are raised to a power of \Sexpr{bad_gower_power} (the default exponent in the \emph{lime} R package \citep{pedersen:2020}). This causes the observations that are further away from the prediction of interest to be given larger weights than the scenario on the left. Here, the explainer model does not capture the linear trend near the prediction of interest, but instead, \sout{the explainer captures} a more global trend. Without an assessment of this explainer model, the slope incorrectly suggests that the predictions decrease as the feature increases near the prediction of interest.

\autoref{fig:figure-01} demonstrates a simple example in which the explanation quality varies drastically when different weights are used. Other concerns \sout{with} LIME have been raised in the literature: \citet{laugel:2018} and \citet{molnar:2019} discuss the difficulty specifying a local region with LIME due to both an unclear definition of \sout{what is} a "local region" and how to apply LIME to achieve an appropriate local region. \citet{laugel:2018} also present examples of LIME explanations that are clearly global and not local. A different concern about LIME is raised by \citet{alvarezmelis:2018} pertaining to the robustness of explanations from LIME and other explainer models: they find that even small changes in predictor variables can lead to very different LIME explanations. Even the original authors of LIME, \citet{ribeiro:2016}, acknowledge that if a linear model is used as the explainer, LIME relies on a linear approximation of the explainer model to the complex model and state "if the underlying model is highly non-linear even in the locality of the prediction, there may not be a faithful explanation".

Without an assessment of the LIME explainer model, the user is putting trust in another black-box \kge{algorithm} \sout{procedure} to explain the complex black-box model. In this paper, we stress the importance of assessing the LIME explainer model. To do this, we lay out the set of claims about LIME made by \citet{ribeiro:2016}, and we provide a toolkit of visual diagnostics  for the assessment of these claims: (1) \emph{explanation scatterplots}, (2) \emph{feature heatmaps}, (3) \emph{assessment metric plots}. Using these visual diagnostics, we demonstrate problematic examples of LIME explanations where the claims about LIME are not met and the explanations are highly dependent on tuning parameter values without a clear way to identify a set of tuning parameter values that produce the "best" explanations.

While LIME is implemented for image, tabular, and text data, we only focus on tabular data. For additional simplicity, we only discuss classification prediction models with a dichotomous response  and continuous predictors. However, the proposed diagnostics may be extended to other situations.

The remainder of the paper is structured as follows. Section ~\ref{background} provides background and claims made by \citet{ribeiro:2016} about LIME. We introduce the suggested diagnostic plots in Section \ref{diagnostics}. Then in Section~\ref{application}, we demonstrate the use of the diagnostics to assess LIME explanations for a random forest fit to a forensics bullet matching dataset. Section~\ref{discussion} concludes with a discussion on extensions and limitations of the diagnostic plots and concerns about LIME in regards to the claims made by~\citet{ribeiro:2016} brought about by the visualization examples in this paper that agree with \citet{alvarezmelis:2018, laugel:2018}, and \citet{molnar:2019}.

All runs of LIME in this paper are executed in a forked version (https://github.com/goodekat/lime) of the R package \emph{lime} (version \Sexpr{packageVersion("lime")}) by \citet{pedersen:2020}. The forked version is functionally indistinguishable from \citeauthor{pedersen:2020}'s implementation but allows us to export internal values relevant for an assessment of the explainer. The code for the diagnostic plots is stored in the R package \emph{limeaid} \citep{goode:2020}.

\section{Background on LIME} \label{background}

The general form of the LIME algorithm can be divided into three steps \citep[see also][]{laugel:2018}:

\begin{enumerate}

\item \emph{Data Simulation and Interpretable Transformation}: Simulate a dataset from the original data used to fit the black-box model. Apply a transformation to the simulated data and the prediction of interest that will allow for interpretable explanations.

\item \emph{Explainer Model Fitting}: Apply the black-box model to the simulated data to obtain predictions. Compute the distance between each of the simulated data points and the prediction of interest. Perform feature selection. Fit an interpretable model with the black-box predictions from the simulated data as the response, the selected features from the transformed simulated data as the predictors, and the distances as weights. This model is the explainer model.

\item \emph{Explainer Model Interpretation}: Interpret the explainer model to determine which features played the most important role in the prediction of interest.

\end{enumerate}

\citet{ribeiro:2016} provide an implementation of LIME in a Python package \cite{ribeiro:2020}. An adaption of the Python package in R has been implemented and made available by \citet{pedersen:2020}. In both implementations, a ridge regression model is used as the explainer model, and the user \sout{is asked to} select\kge{s} various tuning parameter options: the number of features to return in the explanation, the simulation method, the feature selection method, and how the weights are computed. \sout{The discussion of parameter choices and implementation details of LIME in this paper are based on the R package.} See Appendix~\ref{lime-details} for an overview of the options available for the tuning parameters \kge{based on the R package}.

In the original paper, \citet{ribeiro:2016} make the following set of claims regarding the performance of LIME:

\begin{itemize}
\item \emph{Interpretability}: The explainer model can be easily interpreted to provide meaningful explanations.
\item \emph{Faithfulness}: The explainer model sufficiently captures the relationship between the complex model predictions and the features in the local region around a prediction of interest to produce explanations that are faithful to the complex model.
\item \emph{Linearity}: By using a ridge regression model as the explainer model, it is assumed that there is a linear relationship between complex model predictions and the features in the local region around a prediction of interest.
\item \emph{Localness}: The explanations produced by LIME are local in regards to a prediction of interest.
\end{itemize}

<<sine-data, echo = FALSE, include = FALSE>>=

# Functions for rotating the data
rot_x <- function(x, y, theta) (x * cos(theta)) - (y * sin(theta))
rot_y <- function(x, y, theta) (x * sin(theta)) + (y * cos(theta))

# Generate the data
theta = -0.9
min = -10
max = 10
set.seed(20190913)
sine_data <- data.frame(x1 = runif(600, min, max),
                        x2 = sort(runif(600, min, max))) %>%
  mutate(x1new = rot_x(x1, x2, theta),
         x2new = rot_y(x1, x2, theta),
         y = ifelse(x2new > 5 * sin(x1new), "blue", "red")) %>%
  slice(sample(1:n())) %>%
  mutate(x3 = rnorm(600),
         case = 1:600) %>%
  select(case, everything())

# Separate the data into training and testing parts
set.seed(20191003)
rs <- sample(1:600, 500, replace = FALSE)
sine_data_train <- sine_data[rs,]
sine_data_test <- sine_data[-rs,]

# Fit a random forest
set.seed(20191003)
rfsine <- randomForest(x = sine_data_train %>% select(x1, x2, x3),
                       y = factor(sine_data_train$y))

# Obtain predictions on the training and testing data
sine_data_train$rfpred <- predict(rfsine)
sine_data_train <- cbind(sine_data_train, predict(rfsine, type = "prob"))
sine_data_train <- sine_data_train %>% 
  rename(rfprob_blue = blue, rfprob_red = red)
sine_data_test$rfpred <- predict(rfsine, sine_data_test %>% select(x1, x2, x3))
sine_data_test <- cbind(sine_data_test,
                        predict(rfsine, sine_data_test
                                %>% select(x1, x2, x3),
                                type = "prob"))
sine_data_test <- sine_data_test %>% 
  rename(rfprob_blue = blue, rfprob_red = red)

# Save the training and testing data
if(!file.exists("data/sine-data-train.rds")) saveRDS(sine_data_train, "data/sine-data-train.rds")
if(!file.exists("data/sine-data-test.rds")) saveRDS(sine_data_test, "data/sine-data-test.rds")

# Extract the prediction of interest from the sine test data
sine_poi <- sine_data_test %>% filter(y != rfpred, x1 > 0, x1 < 5, x2 > 5)

@

\begin{figure*}[!thp]
\centering
<<figure-02, out.width = '6.5in', fig.width = 8, fig.height = 3.1>>=

# Specify the figure size (for determining font size)
f2_ow = 6.5
f2_fw = 8
f2_fs = fs * (f2_fw / f2_ow)
f2_ls = 0.5 * (f2_fw / f2_ow)

# Create points representing the rotated since curve
sinefun_data <- data.frame(xnew = seq(min(sine_data$x1new),
                                      max(sine_data$x1new),
                                      by = 0.01)) %>%
  mutate(ynew = 5 * sin(xnew)) %>%
  mutate(x = rot_x(xnew, ynew, -theta),
         y = rot_y(xnew, ynew, -theta)) %>%
  filter(y >= -10, y <= 10)

# Specify colors for predictions
sinecolor_red = "firebrick"
sinecolor_blue = "steelblue"

# Plot the training data observed classes
sine_plot_obs <- ggplot(sine_data_train, aes(x = x1, y = x2, color = y)) +
  geom_point(alpha = 0.8) +
  geom_path(data = sinefun_data, aes(x = x, y = y),
            color = "black", 
            size = f2_ls) +
  scale_colour_manual(values = c(sinecolor_blue, sinecolor_red)) +
  theme_bw(base_family = ff, base_size = f2_fs) +
  theme(aspect.ratio = 1, 
        plot.title = element_text(size = f2_fs)) +
  labs(x = TeX("$x_1$"),
       y = TeX("$x_2$"),
       color = TeX("y"),
       title = "Training Data")

# Plot the testing data rf predictions
sine_plot_pred <- ggplot() +
  geom_point(data = sine_poi %>%
               mutate(shape = "Prediction \nof Interest"),
             mapping = aes(x = x1,
                           y = x2,
                           shape = shape),
             size = 5,
             alpha = 0.8,
             color = "black") +
  geom_point(data = sine_data_test %>% filter(y != rfpred),
             mapping = aes(x = x1, y = x2),
             shape = 1,
             size = 3,
             color = "black") +
  geom_point(data = sine_data_test,
             mapping =  aes(x = x1,
                            y = x2,
                            color = rfprob_blue,
                            fill = rfprob_blue),
             shape = 21,
             alpha = 0.8) +
  geom_path(data = sinefun_data, aes(x = x, y = y),
            color = "black", 
            size = f2_ls) +
  scale_color_gradient2(low = sinecolor_red,
                        mid = '#f7f7f7',
                        high = sinecolor_blue,
                        midpoint = 0.5) +
  scale_fill_gradient2(low = sinecolor_red,
                        mid = '#f7f7f7',
                        high = sinecolor_blue,
                        midpoint = 0.5) +
  scale_shape_manual(values = 23) +
  theme_bw(base_family = ff, base_size = f2_fs) +
  theme(aspect.ratio = 1,
        plot.title = element_text(size = f2_fs)) +
  labs(x = TeX("$x_1$"),
       y = TeX("$x_2$"),
       color = "Random \nForest \nProbability \nfor 'blue'",
       fill = "Random \nForest \nProbability \nfor 'blue'",
       title = "Testing Data",
       shape = "") +
  guides(shape = guide_legend(order = 1))

# Join the plots
plot_grid(sine_plot_obs, sine_plot_pred,
          nrow = 1,
          rel_widths = c(0.4825, 0.5175))

@
\caption{Plots of $x_2$ versus $x_1$ from the \data \ training (left) and testing (right) sets introduced in Section \ref{diagnostics} with the true classification boundary shown as a solid black line. In the testing set, the open black circles identify cases misclassified by the random forest, and the diamond indicates a prediction of interest.}
\label{fig:figure-02}
\end{figure*}

The assumption of interpretability only depends on the complexity of the model used as explainer model. If the model is too complex to provide meaningful explanations (e.g. there are too many variables in the model), it is clear that the assumption of interpretability is violated. The other three assumptions are not as easy to assess, and for those, we suggest the use of diagnostic plots.

\section{Visual Diagnostics for LIME} \label{diagnostics}

<<sine-lime>>=

# Apply LIME with various tuning parameters to the sine data
if (!file.exists("data/sine-lime-explain.rds")) {

    # Apply lime with various input options
    sine_lime_explain <- apply_lime(
      train = sine_data_train %>% select(x1, x2, x3),
      test = sine_data_test %>% select(x1, x2, x3),
      model = rfsine,
      label = "blue",
      n_features = 2,
      sim_method = c('quantile_bins', "kernel_density"),
      nbins = 2:6,
      feature_select = "auto",
      dist_fun = "gower",
      kernel_width = NULL,
      gower_pow = 1,
      return_perms = TRUE,
      all_fs = TRUE,
      seed = 20190914)

    saveRDS(sine_lime_explain, "data/sine-lime-explain.rds")
  
    } else {

    sine_lime_explain <- readRDS("data/sine-lime-explain.rds")

  }

@

<<sine-lime-default, warning = FALSE>>=

# Extract the explanations from the default lime application
sine_lime_default <- sine_lime_explain$explain %>% filter(nbins == 4)

# Extract the explanations from the default lime application
# for the prediction of interest only
sine_poi_lime_default <- sine_lime_default %>%
  filter(case == sine_poi %>% pull(case)) %>%
  mutate(case = c("Prediction of Interest", "Prediction of Interest"))

# Obtain the simulated data associated with the poi
sine_poi_perms <- sine_poi_lime_default %>%
  slice(1) %>%
  select(perms_raw, perms_pred_complex, perms_numerified, weights) %>%
  mutate(perms_numerified =
           map(perms_numerified,
               .f = function(x) rename(x,
                                       "x1num" = "x1",
                                       "x2num" = "x2",
                                       "x3num" = "x3"))) %>%
  unnest(cols = c(perms_raw, perms_pred_complex, perms_numerified, weights)) %>%
  select(-red) %>%
  rename(rfpred = blue) %>%
  mutate(case = factor(1:n())) %>%
  select(case, everything())

@

<<sine-poi-explainer, warning = FALSE>>=

# Determine the lime explanation cutoffs
sine_poi_bounds <- sine_poi_lime_default %>%
  select(case, feature, feature_value, feature_desc) %>%
  separate(feature_desc, c("other", "upper"), sep = " <= ") %>%
  separate(other, c("lower", "feature2"), sep = " < ") %>%
  mutate(upper = ifelse(is.na(upper), "Inf", upper)) %>%
  select(-feature2) %>%
  mutate_at(.vars = c("lower", "upper"), .funs = as.numeric)

# Extract the coefficients from the explainer
sine_b0 <- sine_poi_lime_default$model_intercept[1]
sine_b1 <- sine_poi_lime_default$feature_weight[2]
sine_b2 <- sine_poi_lime_default$feature_weight[1]

# Extract the bounds of the bins
x1_lower <- sine_poi_bounds %>% filter(feature == "x1") %>% pull(lower)
x1_upper <- sine_poi_bounds %>% filter(feature == "x1") %>% pull(upper)
x2_lower <- sine_poi_bounds %>% filter(feature == "x2") %>% pull(lower)
x2_upper <- sine_poi_bounds %>% filter(feature == "x2") %>% pull(upper)

# Function for computing the predicted value via the explainer model
sine_explainer <- function(z1, z2) sine_b0 + sine_b1 * z1 + sine_b2 * z2

@

\begin{figure*}[!thp]
<<figure-03, out.width = '6.5in', fig.width = 12, fig.height = 5, warning = FALSE>>=

# Specify the figure size (for determining font size)
f3_ow = 6.5
f3_fw = 12
f3_fs = fs * (f3_fw / f3_ow)
f3_ls = 0.5 * (f3_fw / f3_ow)

# Create the lime R package explanation visualization for the sine data
sine_poi_exp <- 
  sine_poi_lime_default %>% 
  plot_features() + 
  theme(text = element_text(family = ff, size = f3_fs),
        strip.text = element_text(size = f3_fs, face = "plain"))

# Create the explanation scatterplot for the lime explanation for the sine data
exp_scatter <-
  plot_explain_scatter(
    sine_poi_lime_default,
    alpha = 0.4,
    line_size = f3_ls
  ) +
  facet_grid(switch = "both") +
  labs(
    x = TeX("x_1"),
    y = TeX("x_2"),
    size = "Weight",
    shape = "",
    fill = "Random \nForest \nProbability \nfor 'blue'",
    color = "Random \nForest \nProbability \nfor 'blue'",
    linetype = "",
    title = "Explanation Scatterplot"
  ) +
  theme_bw(base_family = ff, base_size = f3_fs) +
  guides(shape = guide_legend(order = 1),
         size = guide_legend(
           nrow = 2,
           byrow = T,
           override.aes = list(alpha = 1)
         )) +
  theme(aspect.ratio = 1,
        plot.title = element_text(size = f3_fs)) 

# Join the plots
plot_grid(sine_poi_exp, exp_scatter) 

# Save the figure to use in the GitHub repo readme
# ggsave(
#   filename = "figure-readme.png",
#   plot = plot_grid(sine_poi_exp, exp_scatter),
#   width = 12,
#   height = 5
# )

@
\caption{(Left) Visualization from the \emph{lime} R package of a LIME explanation for the \data \ prediction of interest identified in \autoref{fig:figure-02}. (Right) \emph{Explanation Scatterplot}.  An explanation scatterplot associated with the explanation on the left. The 4-quantile-bins over-simplify the relationship between the random forest predictions and the $x_1$ and $x_2$ values near the prediction of interest.}
\label{fig:figure-03}
\end{figure*}

In this section, we introduce three visual diagnostic plots that assess the LIME claims from different perspectives:

\begin{enumerate}
\item \emph{Explanation Scatterplot} (Section \ref{exp-scatter}): Comparison of the explainer and complex models for an individual prediction of interest.
\item \emph{Feature Heatmap} (Section \ref{feat-heat}): Comparison of features selected by LIME across applications of LIME with different tuning parameter values.
\item \emph{Assessment Metric Plot} (Section \ref{assess-metric}): Comparison of performance metrics for LIME across applications of LIME with different tuning parameter values. 
\end{enumerate}

\paragraph{The \data}

To demonstrate the visual diagnostics, we generate an example dataset that will be referred to as the \data. The \data \ contains \Sexpr{dim(sine_data)[1]} observations with  features of $x_1$ and $x_2$ independently sampled from Unif(\Sexpr{min}, \Sexpr{max}) distributions and $x_3$ sampled from a $\mbox{N}(0,1)$ distribution. A binary response variable $y$ is created using a sine curve such that
\begin{eqnarray}\label{eq:data}
  y=\begin{cases}
  \mbox{blue} & \mbox{ if } x'_2 > \sin\left(x'_1\right) \\
  \mbox{red} & \mbox{ if } x'_2 \le \sin\left(x'_1\right) \ .
  \end{cases}
\end{eqnarray}
where $x'_1=x_1\cos(\theta)-x_2\sin(\theta)$,  $x'_2=x_1\sin(\theta)+x_2\cos(\theta)$, and  $\theta=-0.9$. Note that due to the creation of $y$ in this manner, $y$ is dependent on $x_1$ and $x_2$ and independent of $x_3$. The dataset is randomly divided into training and testing sets of \Sexpr{dim(sine_data_train)[1]} and \Sexpr{dim(sine_data_test)[1]} observations, respectively. A random forest is fit to the training set using the R package \emph{randomForest} (version \Sexpr{packageVersion("randomForest")}) \citep{liaw:2002} with the default settings and is applied to the test set to obtain predictions. 

\autoref{fig:figure-02} shows scatterplots of $x_2$ versus $x_1$ from the training data (left) and the testing data (right). Both plots include the true classification boundary as the solid black line. The training data are colored by the observed response variable ($y$), and the testing data are colored by random forest prediction probabilities. The random forest misclassifies \Sexpr{dim(sine_data_test %>% filter(y != rfpred))[1]} points, which are all located near the classification boundary and identified by open circles. 

From these scatterplots, we  see that the global relationship between response $y$ and features $x_1$ and $x_2$ is linear: the probability for label blue increases with the difference between features $x_2$ and $x_1$. Locally, the relationship between $y$ and features $x_2$ and $x_1$ varies a lot more around the line of identity. Here, the relationship is determined by the sine wave. However, the sine is a good-natured function that can be approximated well linearly in local regions as shown in \autoref{fig:figure-01}.

We apply LIME using six sets of tuning parameter values to all observations in the \data \ test set to observe explanation variability. Five of the LIME applications use a  quantile bin based simulation method (samples are simulated uniformly from a feature using a specified number of quantile bins) with the number of bins varying from 2 to 6 by application. We use 6 bins as the maximum, because the complexity of the explanations increases with the number of bins. Note that 4-quantile-bins is  the default method in the \emph{lime} R package. The sixth application of LIME uses a kernel density simulation method (samples are drawn from kernel density approximations of the feature distributions). The default methods for feature selection (forward selection) and the computation of the weights (Gower distance raised to an exponent of 1) are used for all applications. See Appendix~\ref{lime-details} for more detailed descriptions of the tuning parameters.

For the presentation of the explanation scatterplot, we focus on the misclassified point indicated by a diamond in \autoref{fig:figure-02}. Misclassified points are often of interest to explain since they may provide information about ways to improve the model. For the introduction of the other two plots, we consider the LIME explanations for all observations in the \data \ test set.

\paragraph{A Visual Representation of a LIME Explanation}

Before introducing the visual diagnostics, let us consider a commonly used visualization of a LIME explanation. \autoref{fig:figure-03} (left) depicts the explanation for the prediction of interest indicated in \autoref{fig:figure-02} obtained using 4-quantile-bins. In the text at the top, the "Probability" is the random forest probability of \Sexpr{round(sine_poi_lime_default$label_prob[1], 2)} that the observation of interest belongs to the "Label" category of blue. The "Explanation Fit" is the deviance ratio of \Sexpr{round(sine_poi_lime_default$model_r2[1], 2)} associated with the ridge regression explainer model (often interpreted as an $R^2$), which suggests that the explainer model is not a good linear fit.

\sout{Since 4-quantile-bins} \kge{When quantile bins} are used to simulate data, LIME converts continuous predictor variables to indicator variables identifying whether the variable value falls in the same quantile bin as the prediction of interest or not. The indicator variables are used as the features in the ridge regression explainer model. The features included in the visualization are the ones selected by feature selection, the lengths of the bars represent the coefficients from the ridge regression associated with the indicator variables, while the color of a bar denotes the sign of the coefficient. This explainer model suggests that a random forest prediction of `blue' for this observation is mostly supported by the prediction of interest having a value of $x_2$ that is greater than \Sexpr{str_split(sine_poi_lime_default$feature_desc[[1]], pattern = " ")[[1]][1]} but somewhat contradicted by the prediction of interest having a value of $x_1$ that is greater than \Sexpr{str_split(sine_poi_lime_default$feature_desc[[2]], pattern = " ")[[1]][1]} and less than or equal to \Sexpr{str_split(sine_poi_lime_default$feature_desc[[2]], pattern = " ")[[1]][5]}. %\kgc{I decided to leave the values here. I actually prefer it this way myself, but I cut out a lot of text from this subsection in other ways.}\hh{XXX }

\subsection{Explanation Scatterplots} \label{exp-scatter}

As a first check to determine whether the explanation depicted in \autoref{fig:figure-03} (left) is trustworthy, we note that since the support for blue by $x_2$ outweighs the support for red by $x_1$, the explainer model overall favors a label of blue for the prediction of interest agreeing with the random forest probability. In fact, both random forest and explainer model classify the observation incorrectly. However, based on the information in \autoref{fig:figure-03} (left) alone, it is not possible to make an informed assessment of the explanation. 

For a further assessment of the explainer model, we turn to an \emph{explanation scatterplot}: a visual diagnostic for assessing the LIME claims of locality and fidelity for an individual explanation by juxtaposing the complex and explainer models in one plot. The format of an explanation scatterplot depends on the LIME simulation method. We introduce the explanation scatterplot here under the \emph{lime} R package default method of 4-quantile-bins. \kge{See the supporting information for} \sout{Appendix \ref{exp-scatter_plus} addresses the} explanation scatterplot formats \kge{under} \sout{in} other LIME simulation scenarios.

The explanation scatterplot applies the concept of plotting the model in the data space discussed in \citet{wickham:2015}. The \kge{visualization} \sout{plot} is built by plotting the LIME simulated data for the top two features identified by the explanation in a scatterplot and coloring these points by the predictions from the complex model. The point size represents the weight assigned by LIME. In order to show the LIME results for the observation of interest, lines are drawn on top of the points representing the boundaries of the indicator variables used to fit the explainer model. The line color denotes whether LIME indicates that a feature supports or contradicts a class prediction. 

An explanation scatterplot corresponding to the LIME explanation depicted on the left in \autoref{fig:figure-03} is shown on the right hand side of \autoref{fig:figure-03}. By juxtaposing the random forest predictions and the explainer model boundaries, we are able to assess the faithfulness and localness of the explainer model. 

First, consider the claim of localness. The weights decay relatively slowly outside of the intersection of the \kge{two quantile bins} \sout{2-quantile-bin} suggesting that the LIME explanation is highly influenced by points outside of the bins containing the prediction of interest. However, it is difficult to say if the claim of localness has been violated, because a definition of a local region is not specified. Depending on what region a viewer considers to be local, an argument could be made in favor of or against a violation of localness. The explanation scatterplot raises awareness of the unclear definition of a local region with LIME. \sout{Nevertheless, it is possible to say that the weights assigned to the simulated data do not capture the local region identified by the intersection of the quantile bins.}

Now, consider the claim of faithfulness: It can be said that the majority of the points in the $x_2$ quantile \kge{bin} support a prediction of blue, which is captured by the bar supporting a prediction of blue in the LIME explanation, and a similar statement can be made about the $x_1$ quantile-bin. These statements validate the explanation produced by LIME. However, the explanation scatterplot plot shows that the random forest performs well at capturing the sine curve classification boundary by creating various sized rectangles consisting of predictions with similar probabilities, which the LIME explanation does not pick up on since the bins are created without information about the random forest predictions. Thus, LIME does provide an explanation for the prediction, but it is a very poor explanation in terms of faithfulness to the random forest prediction regions.

It is difficult to assess linearity from this explanation scatterplot, but a residual plot of the explainer model could be used to check the linearity claim. See Appendix~\ref{residual-plot} for the residual plot associated with the explanation considered in \autoref{fig:figure-03}, which shows a violation of the linearity claim.

This example explanation \kge{scatterplot} only includes two features. In situations where more than two features are included in a LIME explanation, the explanation scatterplots can be extended to a generalized pairs plot \citep{emerson:2013} that includes all pairwise combinations of features. Generalized pairs plots (and scatterplot matrices in general) have diminishing value when the number of features increase \citep{jensen:2011} \citep{sweller:2011}. Machine learning models are commonly fit using a large number of features, and therefore, a generalized pairs plot of explanation scatterplots for all features would be ineffective. However, when applying LIME, the user selects the number of features to return in the explanation. In the \emph{lime} R package, \citet{pedersen:2020} encourage users to select less than 10 features. As long as a small number of features are returned in the LIME explanation, it is feasible to use a generalized pairs plot of explanation scatterplots. An example is shown in Section~\ref{bullet-assess-ex}.

\subsection{Feature Heatmap} \label{feat-heat}

Explanations produced by LIME are likely to be affected by the choice of tuning parameter values. A hypothetical example of this is shown by Figure\sout{s} \ref{fig:figure-01} \sout{and \ref{fig:figure-02} }where the method used to weight the observations influenced the explanation. As of the time of writing this manuscript, we have encountered no recommendations for how to specify the parameter values besides for the default settings in the \emph{lime} R package. In order to compare the explanations produced by LIME using different tuning parameter values and provide another perspective for assessing localness, we visualize an overview of the explanations with the \emph{feature heatmap} diagnostic plot. 

The feature heatmap uses colors to identify the features selected by LIME across multiple predictions (referred to as cases here) and tuning parameter values organized by the feature importance assigned by LIME. That is, for LIME applied with $t$ sets of tuning parameter values to $n$ cases to select the $f$ top features, create $f$ heatmaps (one for each of the positions of importance determined by the magnitude of the explainer model coefficients) with the cases on the $y$-axis, the tuning parameter values on the $x$-axis, and the cells colored by the feature chosen for the corresponding case and tuning parameter value. Additional tuning parameters may also be included in the plot via facets. 

When interpreting feature heatmaps, horizontal lines of the same color represent the ideal situation where the explanations are consistent and do not depend on the tuning parameter values but do depend on the location of the observation in the feature space. Vertical lines of color represent explanations that are dependent on the tuning parameter values and may not be local since the same feature is chosen regardless of the location of the observation in the feature space. See \kge{the supporting information} \sout{Appendix \ref{feat-heat-ex}} for hypothetical examples depicting \kge{the extreme cases of} feature heatmaps\kge{.} \sout{with the extreme cases of horizontal and vertical lines.} \kgc{Remove?}

\begin{figure}[!tp]
<<figure-04, out.width = '3.125in', fig.width = 4.5, fig.height = 4.5>>=

# Specify the figure size (for determining font size)
f4_ow = 3.125
f4_fw = 4.5
f4_fs = fs * (f4_fw / f4_ow)

# Create the example feature heatmap with the sine data
plot_feature_heatmap(sine_lime_explain$explain,
                     order_method = "PCA") +
  theme_bw(base_family = ff, base_size = f4_fs) +
  theme(
    legend.position = "bottom",
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    strip.background = element_rect(color = "white", fill = "white")
  ) +
  labs(y = "Case")

@
\caption{\emph{Feature Heatmap}. An example feature heatmap \sout{of the explanations} from the applications of LIME \sout{with different tuning parameter values} to the \data \ test set. The vertical striping indicates that the LIME explanations are not consistent across tuning parameter values.}
\label{fig:figure-04}
\end{figure}

\autoref{fig:figure-04} shows a feature heatmap for the LIME applications to the 100 observations in the \data \ test set. The most important and second most important features selected by LIME are shown in in the top and bottom facets, respectively. For the quantile bins, the original features prior to being converted to indicator variables are included since it is obvious that different features would be selected when the sizes of the bins change. This figure shows that for kernel density and 2-quantile-bins, LIME produces global explanations since $x_1$ is selected as the most important feature and $x_2$ is selected as the second most important feature across all cases in the test set. There is variability in the features selected by LIME for 3- to 6- quantile-bins suggesting more local explanations. There are signs of vertical striping, which suggests a dependence on tuning parameters. Note that the explanations from 3- and 5-quantile-bins include the selection of the random noise variable ($x_3$) as an important variable in many predictions\sout{, which would not be expected to be important to a random forest}. It is unclear whether the random forest is using a variable that would not be expected to be important or LIME is incorrectly identifying the important variable when 3- and 5- quantile bins are used.

\subsection{Assessment Metric Plot} \label{assess-metric}

The feature heatmap for the \data \ in the previous section shows an example of inconsistent LIME explanations across tuning parameter values. In this situation, the user must determine which set of explanations to trust. One way to do this is to compute assessment metrics for each set of explanations to identify the optimal tuning parameter values. We discuss three metrics for this purpose and present a visual comparison in an \emph{assessment metric plot}.

Each metric presented below is computed on LIME explanations for a set of predictions obtained using the same tuning parameter values. Here we provide a high level description of the metrics. Notation and formulas for these metrics are included in Appendix \ref{metric-details}.

\begin{itemize}
\item \emph{Average $R^2$}: Assesses the model fit and linearity claim by computing the average of the explainer model $R^2$ values (deviance ratios from the R package \emph{glmnet}).

\item \emph{Average Fidelity}: Measures the faithfulness of the explainer model to the complex model by comparing their predictions. Computed as the average of the explainer model fidelity metrics: a metric presented in \citet{ribeiro:2016} (the weighted distance between explainer and complex model predictions for all observations in the LIME simulated data associated with an individual prediction of interest). 

\item \emph{Mean Squared Explanation Error (MSEE)}: Also measures the faithfulness of the explainer model to the complex model by comparing their predictions, but only the prediction of interest is used to compute an average squared deviation between explainer and complex model predictions.
\end{itemize}

\begin{figure}[!bp]
<<figure-05, out.width = '3.25in', fig.width = 4.5, fig.height = 3.75, warning = FALSE>>=

# Specify the figure size (for determining font size)
f5_ow = 3.25
f5_fw = 4.5
f5_fs = fs * (f5_fw / f5_ow)

# Create the metric plot
plot_metrics(sine_lime_explain$explain, rank_legend = "discrete") +
  theme_bw(base_family = ff, base_size = f5_fs) +
  theme(
    strip.background = element_rect(color = "white", fill = "white"),
    strip.placement = "outside",
    strip.text.y = element_text(size = f5_fs)
  )

@
\caption{\emph{Assessment metric plot}. This example assessment metric plot \sout{contains metrics computed on} \kge{is from} the applications of LIME to the \data \ test set. The kernel density simulation method\sout{s} performs well across all three metrics.}
\label{fig:figure-05}
\end{figure}

\autoref{fig:figure-05} shows an example assessment metric plot. The three metrics are computed for each of the LIME applications to the \data \ test set. The simulation methods are listed on the x-axis. The plot is faceted by metric, and the metric values are plotted on the y-axis. The \kge{point} color\sout{s of the points} represent the rank of the simulation methods performance based on a particular metric (darker indicates a better metric value and lighter indicates a worse metric value). Higher average $R^2$ values are better, and lower average fidelity and MSEE values are better. This example only includes one tuning parameter: the simulation method. If more than one tuning parameter is considered, the assessment metric plot is extended by adding additional facets\kge{, point shapes,} or levels to the x-axis.

All three metrics suggest that the kernel density method perform\sout{ed} well, but the metrics disagree for the quantile bin\sout{s} methods. Average $R^2$ and average fidelity rank the performance of the number of quantile bins the same (2-quantile-bins perform the best and 6-quantile-bins perform the worst). In fact, these two metrics appear to have a mirrored relationship in this example. MSEE provides almost the exact opposite results with 6-quantile-bins performing the best and 2-quantile-bins performing the worst. Average fidelity and MSEE are similar metrics, but MSEE only takes the prediction of interest into account and not the full simulated dataset as average fidelity does. This suggests that 6-quantile-bins produce an explainer model more faithful for the prediction of interest while 2-quantile-bins produce an explainer model more faithful over all simulated data observations \kge{(weighted by proximity to the prediction of interest)}. 

Recall, \autoref{fig:figure-04} shows the kernel density method returns the same explanations across all cases in the test set suggesting a global trend may be the best explanation for this example. This may be reasonable considering that we would expect $x_1$ and $x_2$ to be  the two features used by the random forest to distinguish between response categories. However, further exploration of individual explanations using explanation scatterplots may help to identify the tuning parameter values that produce the most trustworthy explanations.

\section{Application to Bullet Matching Data} \label{application}

In this section, we apply the visual diagnostics for LIME explanations to a practical data problem investigating the similarity of marks on fired bullets.

\subsection{Bullet Matching Data}

<<bullet-data>>=
# Load the bullet matching training and testing data
bullet_train <- readr::read_csv("data/bullet-train.csv.zip")
bullet_test <- readr::read_csv("data/bullet-test.csv.zip")
@

<<bullet-rf>>=

# Extract the features from the original random forest model (rtrees)
bullet_features <- rownames(bulletxtrctr::rtrees$importance)
bullet_rf_ntrees <- bulletxtrctr::rtrees$ntree
bullet_rf_mtry <- bulletxtrctr::rtrees$mtry

# Train a new random forest that mimics the rtrees models 
# (or load if already trained)
bullet_rf_file = "./data/bullet-rf.rds"
if (!file.exists(bullet_rf_file)) {
  set.seed(20200923) # the day that the updated data was found :)
  bullet_rf <-
    randomForest(
      y = factor(bullet_train$samesource),
      x = bullet_train %>% select(all_of(bullet_features)),
      ntree = bullet_rf_ntrees,
      mtry = bullet_rf_mtry
    )  
  saveRDS(object = bullet_rf, file = bullet_rf_file)
} else {
  bullet_rf = readRDS(file = bullet_rf_file)
}

# Add variables to both training and testing data with the random forest probability
# that the signatures are a match from the model bullet_rf
bullet_train$rfscore = predict(bullet_rf, bullet_train %>% select(all_of(bullet_features)), type = "prob")[,2]
bullet_test$rfscore = predict(bullet_rf, bullet_test %>% select(all_of(bullet_features)), type = "prob")[,2]

# Compute OOB model metrics
bullet_rf_oob_acc = round(sum(predict(bullet_rf) == bullet_train$samesource) / length(bullet_train$samesource), 2)
bullet_rf_oob_fp = round(bullet_rf$confusion[,3][2], 2)
bullet_rf_oob_fn = round(bullet_rf$confusion[,3][1], 4)

# Obtain model predictions and confusion matrix from test data
bullet_test_pred = predict(bullet_rf, bullet_test %>% select(all_of(bullet_features)))
bullet_test_confus = table(bullet_test_pred, bullet_test$samesource)

# Compute test data model metrics
bullet_rf_test_acc = round(sum(bullet_test_pred == bullet_test$samesource) / length(bullet_test$samesource), 2)
bullet_rf_test_fp = round(bullet_test_confus[2,1] / (bullet_test_confus[2,1] + bullet_test_confus[2,2]), 2)
bullet_rf_test_fn = round(bullet_test_confus[1,2] / (bullet_test_confus[1,1] + bullet_test_confus[1,2]), 4)
@

<<bullet-feature-importance>>=
# Order the features based on feature importance
bullet_features_ordered <-
  data.frame(
    feature = rownames(bullet_rf$importance),
    MeanDecreaseGini = bullet_rf$importance
  ) %>%
  arrange(desc(MeanDecreaseGini)) %>%
  mutate(
    feature = fct_recode(feature,
      "Cross Correlation\nFunction" = "ccf",
      "Consecutively\nMatching Striae" = "cms",
      "Matches" = "matches",
      "Mismatches" = "mismatches",
      "Non-Consecutively\nMatching Striae" = "non_cms",
      "Rough\nCorrelation" = "rough_cor",
      "Distance Standard\nDeviation" = "sd_D",
      "Distance" = "D",
      "Sum of Peaks" = "sum_peaks"
    )
  )

# Create an ordered version of the data
bullet_features_ordered <-
  bullet_features_ordered %>%
  mutate(feature = factor(feature, levels = bullet_features_ordered$feature))

@

In current practice, forensic firearm examiners evaluate whether two bullets are from the same source (fired from the same gun) or from different sources based on microscopic comparison of the striation patterns engraved on bullets during the firing process (see \autoref{fig:figure-06}). The process is based on a visual and therefore subjective assessment of the evidence. The lack of objective evaluation and the associated absence of established error rates has first been criticized by the National Research Council \cite{nrc:2009} and later by the President's Council of Advisors on Science and Technology \cite{pcast:2016}.

In response, \citet{hare:2017} proposed an automated machine learning method for bullet matching to complement a visual inspection by firearm examiners. Based on high-resolution topological scans of land engraved areas, \citet{hare:2017} obtain signatures of striations from two bullet lands (\autoref{fig:figure-07}). Nine features quantifying the similarity of signatures, such as the cross-correlation function, the distance between signatures, and the number of matching striae, are extracted and used to train a random forest to determine the probability of a comparison resulting from the same source (matching signatures) or from different sources (non-matching signatures). The model in \citet{hare:2017} was trained on a set of scans of bullets from the James Hamby Consecutively Rifled Ruger Barrel Study \citep{hamby:2009}, which included 10,384 land-to-land comparisons \citep{hare:2017}. See the supporting information for additional information on the signature similarity features.

\begin{figure}[!t]
\centering
<<figure-06, out.width = '2.25in', fig.width = 6, fig.height = 3, warning = FALSE>>=

# Convert the bullet figure to eps (if needed)
if (!file.exists("figure-static/figure-06-1.eps")) {
  unzip(zipfile = "figure-static/figure-06-1.png.zip", exdir = "figure-static")
  bullets <- image_read("figure-static/figure-06-1.png")
  image_write(bullets, path = "figure-static/figure-06-1.eps", format = "eps")
}

# Load and print the plot
knitr::include_graphics("figure-static/figure-06-1.eps")

@
\caption{(Top left) Traditionally rifled gun barrel. The grooves and lands alternate to give bullets a spin during the firing process, which create markings (striations) on a bullet when fired. (Top right) Image of a fired bullet. The vertical stripes along the lower half of the bullet show groove and land engraved areas. The land engraved areas contain the microscopic striations created when the bullet passed through the barrel of the gun. (Bottom) Close up of a land engraved area showing striations (vertical lines).}
\label{fig:figure-06}

\vspace*{\floatsep}

<<figure-07, out.width = '3.125in', fig.width = 6, fig.height = 3.25, warning = FALSE>>=

# Specify the figure size (for determining font size)
f7_ow = 3.125
f7_fw = 6
f7_fs = fs * (f7_fw / f7_ow)

# Load the signatures data
signatures <- readr::read_csv("data/example-signatures.csv.zip")

# Create plot of the signatures
signatures %>%
  ggplot(aes(x = x/1000, y = y)) + 
  geom_line() +
  facet_grid(land ~ .) +
  ylim(c(-4,6)) +
  theme_bw(base_family = ff, base_size = f7_fs) +
  theme(strip.background = element_blank()) +
  ylab("Surface Measurement \n(in microns)") +
  xlab("Relative Location (in millimeters)") 

@
\caption{Example bullet signatures. The signatures are from the same land and therefore have very similar patterns.}
\label{fig:figure-07}
\end{figure}

\subsection{Application of LIME to Bullet Matching Data}

\begin{figure*}[!thp]
<<figure-08, out.width = '6.5in', warning = FALSE>>=

# File names for parallel coordinate plot
pcp_file_name_png = "figure-static/figure-08-1.png"
pcp_file_name_eps = "figure-static/figure-08-1.eps"

# Create the parallel coordinate plot (if needed)
if (!file.exists(pcp_file_name_png) | !file.exists(pcp_file_name_eps)) {

  # Specify the figure size (for determining font size)
  f8_ow = 6.5
  f8_fw = 7.5
  f8_fs = 7 * (f8_fw / f8_ow)
  f8_ls = 0.5 * (f8_fw / f8_ow)

  # Create the plot
  bullet_pcp <-
    bullet_train %>%
    select(all_of(bullet_features), samesource, rfscore) %>%
    bind_rows(bullet_test %>%
                select(all_of(bullet_features), samesource, rfscore),
              .id = "set") %>%
    mutate(
      set = fct_recode(set,
                       "Training Set" = "1",
                       "Testing Set" = "2"),
      samesource = fct_recode(
        factor(samesource),
        "Match" = "TRUE",
        "Non-Match" = "FALSE"
      )
    ) %>%
    rename(
      "Cross Correlation\nFunction" = "ccf",
      "Consecutively\nMatching Striae" = "cms",
      "Matches" = "matches",
      "Mismatches" = "mismatches",
      "Non-Consecutively\nMatching Striae" = "non_cms",
      "Rough\nCorrelation" = "rough_cor",
      "Distance Standard\nDeviation" = "sd_D",
      "Distance" = "D",
      "Sum of Peaks" = "sum_peaks"
    ) %>%
    arrange(rfscore) %>%
    ggplot(aes(color = rfscore)) +
    geom_pcp(
      mapping = aes(vars = vars(bullet_features_ordered$feature)),
      alpha = 0.2,
      size = f8_ls
    ) +
    facet_grid(set ~ samesource) +
    scale_color_gradient2(low = "grey50",
                          high = "darkorange",
                          midpoint = 0.5) +
    theme_bw(base_family = ff, base_size = f8_fs) +
    theme(
      axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
      strip.placement = "outside",
      strip.background = element_rect(color = "white",
                                      fill = "white")
    ) +
    labs(x = "Features Ordered by Random Forest Variable Importance \n(highest to lowest from left to right)",
         y = "Scaled Feature Values",
         color = "Random \nForest \nProbability")

  # Save the plot
  ggplot2::ggsave(
    plot = bullet_pcp,
    filename = pcp_file_name_png,
    width = 7.5,
    height = 3.5,
    units = "in",
    dpi = 400
  )

  # Load the figure and then save as an EPS file
  bullet_pcp <- image_read(pcp_file_name_png)
  image_write(bullet_pcp, path = pcp_file_name_eps, format = "eps")

}

# Load and print the plot
knitr::include_graphics(pcp_file_name_eps)

@
\caption{Parallel coordinate plots of the bullet matching random forest predictions. Each line corresponds to an observation, and the line color represents the associated random forest probability. There are clear relationships between the feature values and the random forest probabilities.}
\label{fig:figure-08}
\end{figure*}

Since firearm identification is commonly used as evidence for convictions in court cases, it is important to be able to understand and assess a model used to quantify the probability that a bullet is fired from a gun. LIME explanations would provide a local explanation for an individual prediction, but just as it is important to assess the model for this high-stakes application, it is also important to assess the LIME explanations. We will demonstrate an assessment of LIME explanations using the visual diagnostics introduced in this paper.

A random forest model fit to an expanded dataset of \Sexpr{format(dim(bullet_train)[1], big.mark = ",")} land-to-land comparisons from two sets of bullets in the James Hamby Consecutively Rifled Ruger Barrel Study \citep{hamby:2009} was validated in \citet{vanderplas:2020}. Here, we train a random forest model to mimic the model validated in \citet{vanderplas:2020} using the same data, model structure, and features (the nine similarity measures developed in \citet{hare:2017}). We apply the trained random forest model to 6 bullets from another set of the Hamby study with \Sexpr{dim(bullet_test)[1]} rows of land comparisons. See the supporting information for further descriptions of the data. 

The newly trained random forest has an out-of-bag accuracy of \Sexpr{bullet_rf_oob_acc} and out-of-bag false positive and false negative rates of \Sexpr{bullet_rf_oob_fp} and \Sexpr{bullet_rf_oob_fn}, respectively. On the test data, the random forest performance decreases with an accuracy of \Sexpr{bullet_rf_test_acc} and false positive and false negative rates of \Sexpr{bullet_rf_test_fp} and \Sexpr{bullet_rf_test_fn}, respectively. This is an example where explanations of the model predictions could provide insight to the cause of the decrease in model performance on the test data.

In \autoref{fig:figure-08}, we consider a global visualization of the relationship between the random forest predictions and the model features with a parallel coordinate plot of the training data (top row) and testing data (bottom row). In the training data we observe a clear difference in feature values based on whether the corresponding random forest scores are close to 1 or 0. High values of rough correlation, cross correlation function, and number of matches are indicative of random forest scores close to 1; similarly, low values of mismatches, distance, and non-consecutively matching striae are also associated with random forest scores close to 1. Observations in the test data that are classified incorrectly by the random forest tend to have feature values similar to observations in the training data with similar random forest scores. 

LIME is applied to all test set observations using different tuning parameter values: 12 sampling methods (2- to 6- equally-spaced bins, 2- to 6- quantile-bins, kernel density estimation, and normal approximation) and 3 Gower exponents (0.5, 1, and 10). Thus, a total of $12\times 3=36$ different applications of LIME are performed. We specify that each LIME explanation return 3 features, and feature selection is performed using the default option in LIME, which selects the features with the highest weights in a ridge regression model.

<<bullet-lime>>=

# Apply LIME to all but two cases without returning the permutations
if (!file.exists("data/bullet-lime.rds") | !file.exists("data/bullet-explain.rds")){

  # Apply lime with various input options to the Hamby data
  bullet_lime_explain_noperms <- apply_lime(
    train = bullet_train %>%
      select(all_of(bullet_features)),
    test = bullet_test %>%
      select(all_of(bullet_features)),
    model = bullet_rf,
    label = as.character(TRUE),
    n_features = 3,
    sim_method = c('quantile_bins', 'equal_bins',
                   'kernel_density', 'normal_approx'),
    nbins = 2:6,
    feature_select = "auto",
    dist_fun = "gower",
    kernel_width = NULL,
    gower_pow = c(0.5, 1, 10),
    return_perms = FALSE,
    all_fs = FALSE,
    seed = 20190914)

  # Separate the lime and explain parts of the results
  bullet_lime_noperms <- bullet_lime_explain_noperms$lime
  bullet_explain_noperms <- bullet_lime_explain_noperms$explain

  # Save the output objects
  saveRDS(object = bullet_lime_noperms, file = "data/bullet-lime.rds")
  saveRDS(object = bullet_explain_noperms, file = "data/bullet-explain.rds")
  
} else {

  # Load the files
  bullet_explain_noperms <- readRDS("data/bullet-explain.rds")

}

@

<<bullet-lime-perms>>=

# Specify two cases of interest
bullet_poi_match <- 
  bullet_test %>% 
  filter(land_id1 == "Hamby224-Set11-B1-L5", 
         land_id2 == "Hamby224-Set11-B2-L2") %>% 
  pull(case)
bullet_poi_nonmatch <- bullet_test %>% 
  filter(land_id1 == "Hamby224-Set1-B2-L5", 
         land_id2 == "Hamby224-Set1-BUnk-L3") %>% 
  pull(case)

# Apply LIME to two cases with the permutations returned
bullet_lime_explain_perms <- apply_lime(
  train = bullet_train %>% select(all_of(bullet_features)),
  test = bullet_test %>%
    filter(case %in% bullet_poi_match) %>%
    bind_rows(bullet_test %>%
                filter(case %in% bullet_poi_nonmatch)) %>%
    select(all_of(bullet_features)),
  model = bullet_rf,
  label = as.character(TRUE),
  n_features = 3,
  sim_method = c(
    'quantile_bins',
    'equal_bins',
    'kernel_density',
    'normal_approx'
  ),
  nbins = 4,
  feature_select = "auto",
  dist_fun = "gower",
  kernel_width = NULL,
  gower_pow = 0.5,
  return_perms = TRUE,
  all_fs = FALSE,
  seed = 20190914
)

# Separate the lime and explain parts of the results
bullet_lime_perms <- bullet_lime_explain_perms$lime
bullet_explain_perms <- bullet_lime_explain_perms$explain %>%
  mutate(case = ifelse(case == 1,
                       bullet_poi_match,
                       bullet_poi_nonmatch) %>% as.character())

@

<<bullet-lime-combined>>=

# Determine the application and case number of the poi
# in the no_perms data
poi_cases_no_perms <- bullet_explain_noperms %>%
  filter(case %in% c(bullet_poi_match, bullet_poi_nonmatch),
         nbins %in% c(4, NA),
         gower_pow == 0.5) %>%
  select(case, implementation) %>%
  unique()

# Join the no perms data (with poi removed) with the
# perms data (perms removed)
bullet_explain <- bullet_explain_noperms %>%
  anti_join(poi_cases_no_perms,
            by = c("implementation", "case")) %>%
  bind_rows(
    bullet_explain_perms %>%
      mutate(implementation = fct_recode(implementation,
          "3" = "1",
          "8" = "2",
          "31" = "3",
          "32" = "4"
        )
      ) %>%
      select(
        -perms_raw,-perms_numerified,
        -perms_pred_simple,-perms_pred_complex,
        -weights
      )
  )

@

\subsection{LIME Assessment Visualizations} \label{bullet-assess-ex}

To get an overview of the LIME explanations from the 36 applications, we consider a feature heatmap (\autoref{fig:figure-09}). In addition to facets for simulation method and LIME feature importance, this plot includes a vertical facet for Gower power and a horizontal facet for whether the observation is a known match or non-match. This plot highlights several key features of the LIME explanations from the bullet matching dataset.

First, applications of 2-quantile-bins, 2-equal-bins, and somewhat for the density based simulations produce the same explanations for almost all cases and LIME tuning parameter values, suggesting these explanations are global and not local. Second, within a simulation method, the features selected by LIME for an observation do not appear to vary by the Gower power. However, the LIME explanations for an observation often vary across simulation methods. With the equal bins, there are vertical stripes that suggest a dependence of the LIME explanations on the number of bins. The vertical stripes are not as apparent with the quantile bins. Lastly, there are clear differences between the LIME explanations produced by the bin based simulation methods for the matches and non-matches. This suggests that different features are of importance in the random forest, depending on whether the observation corresponds to match or non-match.

\begin{figure*}[!thp]
<<figure-09, out.width = '6.5in', fig.width = 18, fig.height = 14>>=

# Specify the figure size (for determining font size)
f9_ow = 6.5
f9_fw = 18
f9_fs = fs * (f9_fw / f9_ow)

# Create a feature heatmap
plot_feature_heatmap(
  bullet_explain %>%
    mutate(
      label = as.factor(label),
      feature = fct_recode(
        feature,
        "Rough Correlation" = "rough_cor",
        "Consecutively Matching Striae" = "cms",
        "Distance" = "D",
        "Matches" = "matches",
        "Mismatches" = "mismatches",
        "Non-Consecutively Matching Striae" = "non_cms",
        "Cross Correlation Function" = "ccf",
        "Sum of Peaks" = "sum_peaks",
        "Distance Standard Deviation" = "sd_D"
      )
    ),
  facet_var = bullet_test %>%
    mutate(samesource = fct_recode(
      factor(samesource),
      "Match" = "TRUE",
      "Non-Match" = "FALSE"
    )) %>%
    pull(samesource),
  order_method = "PCA"
) +
  scale_fill_gretchenalbrecht(palette = "last_rays", discrete = TRUE) +
  scale_color_gretchenalbrecht(palette = "last_rays",
                               discrete = TRUE,
                               reverse = TRUE) +
  theme_bw(base_family = ff, base_size = f9_fs) +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    strip.background = element_rect(color = "white", fill = "white"),
    strip.text.y.right = element_text(angle = 0, size = f9_fs*0.7),
    strip.text.x = element_text(size = f9_fs*0.7),
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  guides(fill = guide_legend(nrow = 3)) +
  labs(y = "Case", color = "Complex Model Feature", fill = "Complex Model Feature")

@
\caption{Feature heatmap of 36 LIME applications to the bullet comparison data test set. The vertical stripes of features selected indicate a dependence between the LIME explanations and tuning parameter values.}
\label{fig:figure-09}

\vspace*{\floatsep}

<<figure-10, out.width = '6.5in', warning = FALSE, fig.width = 10, fig.height = 4.25>>=

# Specify the figure size (for determining font size)
f10_ow = 6.5
f10_fw = 10
f10_fs = fs * (f10_fw / f10_ow)
f10_ls = 0.5 * (f10_fw / f10_ow)

# Create a metric comparison plot
plot_metrics(
  bullet_explain %>%
    mutate(label = as.factor(label)),
  add_lines = TRUE,
  line_alpha = 0.75,
  line_size = f10_ls
) +
  theme_bw(base_family = ff, base_size = f10_fs) +
  theme(
    strip.background = element_rect(color = "white", fill = "white"),
    strip.placement = "outside",
    strip.text.y = element_text(size = f10_fs)
  )

@
\caption{Assessment metric plot for the applications of LIME on the bullet comparison data test set. There are discrepancies in metric performances, but overall, 4-equal-bins with a Gower power of 0.5 appear to perform the best.}
\label{fig:figure-10}
\end{figure*}

To try to identify a set of LIME tuning parameter values with the most trustworthy set of explanations, an assessment metric plot is considered (\autoref{fig:figure-10}). The performance of a set of tuning parameter values often do not agree across metrics. For example, both density methods perform well according to average fidelity but poorly according to MSEE. All quantile bin methods perform well according to average $R^2$ but poorly based on average fidelity and MSEE. However, there is consistency in results across different Gower powers. The applications using a power of 0.5 perform the best or as well as the other powers across all simulation methods suggesting that the power that leads to a more local explanation is preferred. It is not obvious  which set of tuning parameters is the best, but considering all three metrics, we might conclude that the 4-equal-bins with a Gower power of 0.5 performs better than the other tuning parameter values considered.

To provide a more detailed view of explanations obtained using different tuning parameter values, we consider explanation scatterplots for one prediction of interest referred to as case NM (a known non-match) shown in Figure~\ref{fig:figure-11} along with the visual explanation plots from the \emph{lime} R package. Plots for 4-equal-bins and 4-quantile-bins are included to depict tuning parameter values with good (4-equal-bins) and mediocre (4-quantile-bins) performance based on the assessment metric plot. \kge{Additional examples of explanation scatterplots including explanations for a known match and explanations produced using the kernel density simulation method are included in the supporting information.} \sout{Explanation scatterplots for a known match, referred to as case M, and for the kernel density simulation method applied to both M and NM are included in Appendix~\ref{bullets-plus}.} 

\kge{Figure~\ref{fig:figure-11} (top left) shows that w}\sout{W}hen 4-quantile-bins are applied to case NM, LIME explains that the values of mismatches, rough correlation, and distance are important and support a prediction of the class true\sout{ (Figure~\ref{fig:figure-11} top left)}. However, this explanation contradicts the random forest prediction which correctly assigns the observation  a non-match. The explanation scatterplot (Figure~\ref{fig:figure-11} bottom left) clarifies the reason for the highly unfaithful explanation. Case NM falls on the boundary of regions for each of these three features where the random forest predictions transition from below 0.5 to above 0.5. However, the regions used when applying LIME from the 4-quantile-bins where case NM falls contain mostly observations with random forest predictions above 0.5, leading to the unfaithful explanation.

Figure~\ref{fig:figure-11} (top right) shows \sout{the LIME explanation for case NM} \kge{that} when 4-equal-bins are used\sout{. Here}, the features \kge{LIME} identifie\sout{d}\kge{s} as important are distance and mismatches, which support a match and matches, which supports a non-match. This explanation is more faithful having at least one feature supporting a non-match and has a better linear fit, but the most important feature identified by LIME still supports a match, contradicting the random forest. The explanation scatterplot (Figure~\ref{fig:figure-11} bottom right) again shows the features supporting a match arise from NM falling on the boundary of random forest prediction regions that are not well captured by the LIME bins.

Without an assessment of the LIME explanations, the default method would produce poor explanations such as the one shown in Figure~\ref{fig:figure-11} (left column). Our assessment here led to better explanations when the four equal bins are used. However, the explanation quality is still lacking from the one prediction considered. Additional investigations using explanations scatterplots would help to determine whether to trust this set of explanations, continue tuning the LIME parameters, or use another approach to provide better insight.

\begin{figure*}[!thp]
<<figure-11, out.width = '6.25in', fig.width = 13, fig.height = 9, message = FALSE>>=

# Specify the figure size (for determining font size)
f11_ow = 6.25
f11_fw = 13
f11_fs = fs * (f11_fw / f11_ow)
f11_ls = 0.5 * (f11_fw / f11_ow)

# Adjust names of the cases
bullet_explain_perms_clean <- bullet_explain_perms %>%
  mutate(case = ifelse(case == bullet_poi_nonmatch, "NM", "M"))

# Save the cleaned explanations to use with the supporting information
if(!file.exists("data/bullet-explain-perms-clean.rds")) {
 saveRDS(bullet_explain_perms_clean, "data/bullet-explain-perms-clean.rds") 
}

# Create a theme for the lime explanation visualizations
bullet_explain_plot_theme <-
  list(
    scale_fill_manual(values = c("darkorange", "grey50")),
    theme(
      text = element_text(family = ff, size = f11_fs),
      strip.text.x = element_text(face = "plain", size = f11_fs)
    )
  )

# Create the lime explanation visualizations
pfNM_3qb <- plot_features(bullet_explain_perms_clean[4:6,]) + bullet_explain_plot_theme
pfNM_3eb <- plot_features(bullet_explain_perms_clean[10:12,]) + bullet_explain_plot_theme

# Create theme for explanation scatterplots
bullet_eoi_plot_theme <-
  list(
    scale_color_gradient2(
      low = "grey50",
      high = "darkorange",
      midpoint = 0.5,
      limits = c(0, 1)
    ),
    scale_fill_gradient2(
      low = "grey50",
      high = "darkorange",
      midpoint = 0.5,
      limits = c(0, 1)
    ),
    theme_bw(base_family = ff, base_size = f11_fs),
    theme(
      aspect.ratio = 1,
      plot.title = element_text(size = f11_fs),
      strip.text.x = element_text(size = f11_fs),
      strip.text.y = element_text(size = f11_fs),
      strip.placement = "outside",
      strip.background = element_rect(color = "white", fill = "white")
    ),
    guides(size = guide_legend(nrow = 2, byrow = T), 
           linetype = guide_legend(override.aes = list(color = c("grey50", "darkorange"))))
  )

# Create the explanation scatterplots
eoiNM_3qb <-
  plot_explain_scatter(
    bullet_explain_perms_clean[4:6, ],
    alpha = 0.9,
    weights = TRUE,
    line_size = f11_ls
  ) +
  bullet_eoi_plot_theme + 
  guides(linetype = guide_legend(override.aes = list(color = c("darkorange"))))
eoiNM_3eb <-
  plot_explain_scatter(
    bullet_explain_perms_clean[10:12,],
    alpha = 0.9,
    weights = TRUE,
    line_size = f11_ls
  ) +
  bullet_eoi_plot_theme

# Join the plots
plot_grid(
  pfNM_3qb,
  pfNM_3eb,
  eoiNM_3qb,
  eoiNM_3eb,
  nrow = 2,
  rel_heights = c(0.4, 0.6)
)

@
\caption{Plots of LIME explanations (first row) and explanation scatterplots (second row) for case NM in the bullet test data for two tuning parameter values: 4-quantile-bins (first column) and 4-equal-bins (second column).}
\label{fig:figure-11}
\end{figure*}

\section{Discussion} \label{discussion}

This paper highlights that while an explainer model is meant to provide clarity, it actually adds another layer of complexity to predictive models by requiring yet another model that needs to be assessed. Without an assessment of the explainer model, LIME is a black-box procedure requiring blind trust in the explainer model. We suggest the use of visual diagnostics to counteract the black-box nature of LIME. We provide three diagnostic plots intended to assess whether LIME explanations meet the claims made by \citet{ribeiro:2016}. The examples in this paper bring to light many scenarios in which the claims are not met or are difficult to assess. We reconsider each of the claims and how the visual diagnostics identify their failings.

As previously discussed, the \textbf{interpretability} of the LIME explanations is controllable by the complexity of the explainer model. For example, the number of bins selected for simulation controls the interpretability of the explanations. If too many bins are selected, the bin range that is reported in the LIME explanation will be too small to be meaningful in the context of the feature. An appropriate choice of the number of bins will keep the bin range meaningful. Thus, the claim of interpretability does not need to be assessed using the visualizations. However, diagnostic visualizations do present a different perspective on the meaning of interpretability.

Even though an explanation will be interpretable if  the complexity of the explainer model is appropriately chosen, a lack of understanding of the explainer model could lead to an incorrect interpretation of the explanation. For example, the visualization of a LIME explanation from the \emph{lime} R package \citep{pedersen:2020} (\autoref{fig:figure-03} left; \autoref{fig:figure-11} top) is a simplification of the explainer model, which could lead to misinterpreted LIME explanations. \kgc{Clarify?} Supplementing \citet{pedersen:2020}'s compact visualization of the explanation with an explanation scatterplot that shows a more detailed visualization of the explainer model promotes a more complete understanding of the explanation (\autoref{fig:figure-03} right; \autoref{fig:figure-11} bottom).

Even with an explainer model that is interpreted correctly, the interpretation is worthless if the explainer model is not \textbf{faithful} to the complex model. Explanation scatterplots allow for a comparison of the explainer model to the complex model. The examples in this paper show cases where the explainer model oversimplifies the model and bins do not accurately capture the regions with similar random forest probabilities that contain the prediction of interest (\autoref{fig:figure-03} right; \autoref{fig:figure-11} bottom). Using fewer bins would clearly not help improve the faithfulness of the explainer model in these examples, and while an increase in the number of bins would lead to a finer resolution of the random forest classification boundaries, interpretability of the explainer model would quickly be lost. Perhaps this could be improved by allowing the bin creation to account for the relationships between the features and response variable or a different number of bins for each feature.

We also propose an assessment metric plot for the visual comparison of two faithfulness metrics: MSEE and average fidelity. Both metrics measure faithfulness, but MSEE only accounts for the prediction of interest while average fidelity accounts for all observations in the simulated data. As a result, the measures may disagree (Figures \ref{fig:figure-05} and \ref{fig:figure-10}), and the user is left to determine which is preferable. 

The metric comparison plot also includes a comparison of average $R^2$ values, which is a metric that can be used to assess the claim of \textbf{linearity}. Most of the average $R^2$ values in the examples from this paper are below 0.5 suggesting a poor linear fit of the explainer models. A poor linear fit of the explainer model is also seen with the residual plot shown in \autoref{fig:figure-B1}.

The final claim, \textbf{localness}, is addressed by feature heatmaps and explanation scatterplots. The vertical stripes seen in the feature heatmaps (Figures \ref{fig:figure-04} and \ref{fig:figure-09}) suggest global explanations produced by LIME since the same explanation is returned for almost all observations regardless of feature values. The explanation scatterplots visualize the locality of the explanation using point size to indicate weight. However, the lack of definition of a local region makes it difficult to assess whether the weights capture an appropriately local region.

These diagnostic visualizations are a starting point that already highlight seemingly common issues with the LIME claims. Additions, such as visualizations of the step-by-step process of the creation of LIME explanations and interactivity \kge{would}\sout{,} enhance the assessment process. For example, a diagnostic plot that provides a summary of multiple LIME explanations, such as the feature heatmap, could be \sout{displayed and} clicked on to reveal more detailed figures\kge{, such as an explanation scatterplot, for a prediction of interest.}\sout{ associated with individual prediction of interest, such as an explanation scatterplot.}

The largest limitation to the diagnostic visualizations is the dimensionality of the data shown, both in the number of dimensions or features as well as the number of observations. Fortunately, in the situation of LIME, both of these aspects are rather well controlled: LIME relies heavily on simulations to generate data scenarios that are close to the data observed but exhibit variability. Effects from overplotting should be relatively mild, because output from simulations is shown, which is expected to be (relatively) continuous such that overplotting only occurs for points with (relatively) similar values. In that respect, the diagnostics shown for the \data \ and the bullet example are representative of what is expected. But in cases where overplotting does become problematic, the user could either simply reduce the size of the simulations or use some well-studied binning techniques in the visualizations, as discussed for example in \citet{carr:1987} or \citet{unwin:2006}. 

While it would be ideal if LIME could be used as a method to provide easily understandable explanations for black-box models as \citet{ribeiro:2016} claim, \kge{there is still work to be done to achieve that} \sout{that dream is not yet a} reality. The examples using diagnostic plots to assess LIME in this paper show frequent instances when the claims about LIME are not met. We hope that our plots provide motivation to assess LIME explanations, to not blindly use the default settings (even if how to tune the parameters is not clear), and to encourage work improving LIME, so that it can be a lime and not a lemon.

\section*{Acknowledgments}

HH was partially funded by the Center for Statistics and Applications in Forensic Evidence (CSAFE) through Cooperative Agreement 70NANB20H019 between NIST and Iowa State University, which includes activities carried out at Carnegie Mellon University, Duke University, University of California Irvine, University of Virginia, West Virginia University, University of Pennsylvania, Swarthmore College and University of Nebraska, Lincoln.

\subsection*{Author contributions}

{\bf Katherine Goode, Heike Hofmann}: Conceptualization, Methodology, Investigation, Visualizations, Writing - Reviewing and Editing. {\bf Katherine Goode}: Writing - Initial Draft, Software.

\subsection*{Financial disclosure}

None reported.

\subsection*{Conflict of interest}

The authors declare no potential conflict of interests.

\section*{Supporting information}

\kge{Additional examples of the visual diagnostics and more info on the bullet matching data may be found in the Supporting Information section of the online version of the manuscript.} The code \sout{used to produce the manuscript} and \sout{the} data \sout{from examples in Section \ref{application}} \kge{associated with the manuscript} are \kge{also included in the online Supporting Information section and} \sout{available} in the following GitHub Repository: \href{https://github.com/goodekat/LIME-diagnostics-paper}{https://github.com/goodekat/LIME-diagnostics-paper}.

\bibliography{references}

\newpage

\appendix

\section{LIME Tuning Parameter Options} \label{lime-details}

The following tuning parameters for the LIME algorithm are available in the \emph{lime} R package \citep{pedersen:2020}.

\begin{itemize}

\item Data simulation methods:

\begin{itemize}
\item Equally spaced bins: observations are uniformly sampled from equally spaced bins (number of bins may be specified)
\item Quantile bins: observations are uniformly sampled from quantile bins (number of bins may be specified)
\item Normal density approximation: observations are sampled from a normal distribution with mean and standard deviation computed from the corresponding feature
\item Kernel density approximation: observations are sampled from an kernel density approximation of the corresponding feature
\end{itemize}

\item Number of observations to simulate

\item Distance metric for determining proximity to the prediction of interest: Gower distance (where the power may be specified) or exponential kernel (where the kernel width may be specified)

\item Number of features to return in an explanation

\item Feature selection method for determining the features to return in an explanation: forward selection applied to a ridge regression, features with the largest magnitude coefficients in ridge regression, LASSO, classification/regression tree splits

\end{itemize}

The \emph{lime} R package uses a ridge regression fit using the \emph{glmnet} R package \citep{simon:2011} as the explainer model. Note that the ridge regression penalty parameter (referred to as $\lambda$ in \emph{glmnet}) is usually treated as a tuning parameter, but the \emph{lime} R package always sets $\lambda$ to 2 divided by the number of observations in the simulated dataset.

\section{Explainer Model Residual Plot} \label{residual-plot}
\begin{figure}[!h]
<<figure-B1, out.width = '3.125in', fig.width = 5, fig.height = 4, warning = FALSE>>=

# Specify the figure size (for determining font size and line size)
fb1_ow = 3.125
fb1_fw = 5
fb1_fs = fs * (fb1_fw / fb1_ow)
fb1_ls = 0.5 * (fb1_fw / fb1_ow)

# Calculate the residuals from the explainer model
y <- sine_poi_perms$rfpred
sine_poi_explainer <-
  function(x1, x2)
    sine_b0 + (sine_b1 * x1) + (sine_b2 * x2)
sine_poi_perms <- sine_poi_perms %>%
  mutate(exppred = sine_poi_explainer(x1num, x2num)) %>%
  mutate(resid = exppred - rfpred)

# Create the residual plot
ggplot(sine_poi_perms, aes(x = exppred, y = resid)) +
  geom_hline(yintercept = 0, size = fb1_ls) +
  geom_jitter(alpha = 0.5, width = 0.02) +
  theme_bw(base_family = ff, base_size = fb1_fs) +
  theme(plot.title = element_text(size = fb1_fs)) +
  labs(x = "Explainer Model Predictions",
       y = "Explainer Model Residuals",
       title = "Explainer Model Residual Plot")

@
\caption{Residual plot of the explainer model associated with \data \ prediction of interest from Section \ref{exp-scatter}, which suggests a violation of the linearity assumption.}
\label{fig:figure-B1}
\end{figure}

In order to assess the claim of linearity for the \data \ prediction of interest discussed in Section \ref{exp-scatter}, we use one of the most basic diagnostics in a statistician's tool box and draw a residual plot for the explainer model. This is shown in \autoref{fig:figure-B1} with the explainer model residuals on the y-axis and explainer model predictions on the x-axis. The points along the x-axis have been jittered to ease the effect of the over-plotted points. There is a clear increasing trend in the residuals as the explainer model predictions increase, which indicates a violation of the ridge regression linearity assumption.

\section{Details on Assessment Metrics} \label{metric-details}

Suppose $f$ is a complex model, and let $\textbf{X}$ be a matrix of observed data with $K$ features and $E$ observations where $x_e$ is an observed feature vector for observation $e$. Let $f(x_e)$ be the complex model prediction for observation $e$. It is of interest to explain the predictions made by $f$ applied to $X$ using LIME. 

For $x_e$ and a set of tuning parameter values $t$, let $\textbf{X}_{e,t}'$ be the LIME simulated dataset with $K$ features and $S$ rows such that $x'_{e,t,s}$ is the feature vector for simulated data point $s$ corresponding to explanation $e$ and tuning parameter values $t$. Let $\textbf{Z}'_{e,t}$ be the matrix of simulated data transformed to bin indicator variables (for bin based simulation methods) or standardization (for density based simulation methods) with $K$ features and $S$ observations such that $z'_{e,t,s}$ is the interpretability transformed feature vector for explanation $e$, tuning parameter values $t$, and simulated data point $s$. Note that $z_{e,t}$ will represent the transformed version of $x_e$.

Next, let $\omega_t$ represent a proximity distance metric corresponding to tuning parameter values $t$. Then $\omega_t\left(x_e, x'_{e,t,s}\right)$ is the weight assigned to $x'_{e,t,s}$, which is the proximity between $x_e$ and $x'_{e,t,s}$. Allow $g_{e,t}$ to be the explainer model for an explanation $e$ and tuning parameter values $t$. Thus, $g_{e,t}\left(z'_{e,s,t}\right)$ is the explainer model prediction for the interpretability transformed simulated data point $s$.

For a set of $E$ explanations and a set of tuning parameter values $t$, we define the assessment metrics as follows:\\
\\
\emph{Average $R^2$} is denoted as $R^2_{\mbox{ave}}$ and computed as

  $$R^2_{\mbox{ave}} = \frac{1}{E}\sum_{e=1}^E R_{e,t}^2$$

\noindent where $R_{e,t}^2$ is the $R^2$ value for $g_{e,t}$.\\
\\
\emph{Average fidelity} is denoted by $\mathcal{L}_{\mbox{ave}}$ and computed as

\begin{eqnarray*} \mathcal{L}_{\mbox{ave}} & = & \frac{1}{E}\sum_{e=1}^E\mathcal{L}(f, \ g_{e,t}, \ \pi_{t}) \\ & = & \frac{1}{E}\sum_{e=1}^E\sum_{s=1}^{S}\omega_{t}\left(x_e, x'_{e,t,s}\right)\left(f\left(x'_{e,t,s}\right)-g_{e,t}\left(z_{e,t,s}'\right)\right)^2. \end{eqnarray*}

\noindent where $\mathcal{L}$ is the fidelity metric originally defined in \citet{ribeiro:2016}.\\
\\
\emph{Mean squared explanation error} is denoted by MSEE and computed as

$$MSEE=\frac{1}{E}\sum_{e=1}^E\left(f\left(x_e\right)-g_{e,t}\left(z_{e,t}\right)\right)^2.$$

\end{document}
